# 1의 개수 세기

## 사용 알고리즘 : dp

### 문제 설명

a, b를 입력 받고 a부터 b까지 있는 모든 수를 이진수로 표현했을 때 1의 개수를 출력한다.

### 풀이 설명

dp[n] : 1부터 2^(n+1)-1까지의 1의 개수
dp[n] = (1부터 2^(n+1)-1까지 1의 개수)
    -> = (1부터 2^(n) - 1까지 1의 개수) + (2^(n) ~ 2^(n+1)-1 까지의 1의 개수)
    -> 2^(n) ~ 2^(n+1)-1에서 1의 개수는 맨 앞에 항상 1이 있으며, 그것을 제외하고는 dp[n]과 같다. 따라서,
    -> (1부터 2^(n) - 1까지 1의 개수) + (1 ~ 2^(n) - 1 까지의 1의 개수) + (1 ~ 2^(n)-1 까지의 숫자의 수)
    -> 2*dp[n-1] + 2^n 

dp는 주어진 수가 2^n꼴일때만을 알려준다. 따라서 임의의 숫자는 재귀적으로 풀어내야 한다.

func(a)를 1~a까지의 모든 1의 개수라고 하면,

func(a) = (if a == 2^n 꼴) dp[a]+1
        = (else) dp[r] + func(a-r) + (a-r+1) ; //(r은 a보다 작은 2^n꼴의 숫자중 가장 큰 수)


### 시간복잡도 : log_2(a)

func(a)는 자신이 가진 1의 숫자만큼 호출되므로, log_2(a)만큼 호출된다.

### 어려웠던 점

1<<40과 같이 비트연산을 할 때에 1이 int로 인식되어서 overflow가 나게 됨. 따라서 long long으로 형변환 혹은 1을 따로 long long으로 선언해주어야 함.